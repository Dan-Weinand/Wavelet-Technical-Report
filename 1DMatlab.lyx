#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass spie
\use_default_options true
\master TechReportAMALTHEA.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
1-D Matlab Implementation
\end_layout

\begin_layout Standard
In coding the 1-dimensional streaming data density estimator we used Mark
 Moyou and Eddy Ihou's architecture, illustrated below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/Matlab Architecture.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Density Estimation Process
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Obtain Samples
\end_layout

\begin_layout Standard
We assume that data has been collected previously and processed into a one-dimen
sional data set.
 It is likewise assumed that the maximum and minimum range for the data
 (or at least the desired support) is known.
\end_layout

\begin_layout Subsection
Calculate Valid translates
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Talk about why having valid translates are better and what you gain when
 you go to higher dimensions.
 
\end_layout

\end_inset

The dyadic Discrete Wavelet Transform (DWT) assumes wavelet functions (father
 and mother) of the form:
\begin_inset Formula 
\[
\varphi_{j,k}(x)=2^{j/2}\varphi(2^{j}x-k)
\]

\end_inset

 where 
\begin_inset Formula $j,k\in\mathbb{{Z}}$
\end_inset

 and 
\begin_inset Formula $\varphi$
\end_inset

 refers to both the father and the mother wavelet functions.
\end_layout

\begin_layout Standard
Also, the majority of the wavelet families used in this implementation of
 the density estimator have a defined support of 
\begin_inset Formula $[0,2N-1]$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the order of the wavelet.
 For example, 
\begin_inset Formula $"db6"$
\end_inset

 (Daubechies wavelet family) is of order 6 and therefore its support is
 
\begin_inset Formula $[0,11]$
\end_inset

.
 For the wavelet function 
\begin_inset Formula $\varphi_{j,k}(x)$
\end_inset

 to be evaluated at a given point, its argument 
\begin_inset Formula $2^{j}x-k$
\end_inset

 has to lie within its support.
 That is:
\begin_inset Formula 
\[
0\le2^{j}x-k\le2N-1
\]

\end_inset

 Solving for 
\begin_inset Formula $k$
\end_inset

, we obtain:
\begin_inset Formula 
\[
2^{j}x-2N+1\le k\le2^{j}x
\]

\end_inset

 Therefore, if the support of the density function is given as 
\begin_inset Formula $[a,b]$
\end_inset

 and the order of the wavelet 
\begin_inset Formula $N$
\end_inset

 is known, the valid translates 
\begin_inset Formula $k$
\end_inset

 will meet the condition
\begin_inset Formula 
\begin{equation}
\lceil2^{j}a\rceil-2N+1\le k\le\lfloor2^{j}b\rfloor\label{eq:Valid translates def}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
Estimate Coefficients
\end_layout

\begin_layout Standard
The bulk of the coding complexity falls into this section.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Remind the reader about the coefficients and even reference the old equation.
 This may be difficult because it was in another file, if it cannot be done
 just copy and paste the 
\begin_inset Formula $f(x)$
\end_inset

 expansion equation.
 Oh and make sure you label your equations
\end_layout

\end_inset

All the coefficients are initialized at zero and then begin to build up
 from there as described in equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Decay Update"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Window update"

\end_inset

).
 We support two methods for updating the coefficients: the sliding window
 method 
\begin_inset CommandInset citation
LatexCommand cite
key "Trevino12"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
remove date and add in the reference, same with Caudle.
 
\end_layout

\end_inset

 as well as the decaying method 
\begin_inset CommandInset citation
LatexCommand cite
key "Wegman06"

\end_inset

.
 
\end_layout

\begin_layout Standard
The sliding window method considers only a finite section of the total data
 set at a time in order to estimate the density function.
 When a data point leaves the data set, it subtracts from the coefficients
 the exact amount which it originally added to them.
 Given the coefficient at the previous time step 
\begin_inset Formula $\hat{b}_{j,n}$
\end_inset

, the window size 
\begin_inset Formula $w$
\end_inset

, and both the entering (
\begin_inset Formula $X_{n+1}$
\end_inset

) and leaving (
\begin_inset Formula $X_{n-w+1}$
\end_inset

) data points, the coefficient at the next step is readily calculated by:
\begin_inset Formula 
\[
\hat{b}_{j,n+1}=\hat{b}_{j,n}+\frac{\varphi(X_{n+1})}{w}-\frac{\varphi(X_{n-w+1})}{w}
\]

\end_inset


\end_layout

\begin_layout Standard
The decaying method of Caudle and Wegman likewise lends itself well to a
 simple recursive updating procedure.
 Specifying a decay rate 0 < 
\begin_inset Formula $\theta$
\end_inset

 < 1, the coefficient at the next time step is given by:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\hat{b}_{j,n+1}=\theta\hat{b}_{j,n}+(1-\theta)\varphi(X_{n+1})
\]

\end_inset


\end_layout

\begin_layout Standard
It is worth noting that for the majority of the wavelets used in estimation,
 no closed form approximation exists.
 Due to this, a table of values defining the wavelet over its support is
 pre-emptively calculated for each type of wavelet.
 Then interpolation was used among these values to calculate the output
 of the scaling basis and wavelet basis functions.
 Profiling of the algorithm's performance puts this interpolation as the
 bottleneck where most of computation time is spent.
 Depending on the granularity of the wavelet table, linear interpolation
 may give satisfactory results while for more widly spaced tables cubic
 interpolation may be necessary to achieve a good approximation of the interpola
ted value.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Mention this interpolation as a bottleneck and also the discretization and
 the need for cubic interpolation depending on the tables.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Calculate Density
\end_layout

\begin_layout Standard
The computational bottleneck lies with this section.
 The actual calculation of the density is fairly simple.
 For each point x in the support, the density is given by:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f(x)=\sum\limits _{k}c_{j_{0},k}\phi_{j_{0},k}(x)+\sum\limits _{j_{0}\leq j}\sum\limits _{k}d_{j,k}\psi_{j,k}(x)
\]

\end_inset


\end_layout

\begin_layout Standard
As it is plainly infeasible to calculate the density at every point in the
 support, a discretization for how frequently to calculate the density is
 selected.
 Empirical tests gives that the computational load for updating the coefficients
 given one new data point is roughly equal to that for calculating the density
 of six points.
 A fine grained density function frequently evaluated can drastically slow
 down the algorithm.
 Likewise, having a coarser grained discretization and reducing the frequency
 at which the entire density is calculated both significantly speed up the
 algorithm.
\end_layout

\begin_layout Subsection
Normalize Density
\end_layout

\begin_layout Standard
While the above calculations will give the proper shape for the density,
 they do not yet create a true probability density function.
 Regions sparse in data may have negative densities and the integral over
 the region almost certainly does not sum to unity.
 In order to correct these types of errors, we use the iterative method
 for improving density methods described in Gajek 1986.
 The essence of the method is to first set all negative values in the density
 to zero, then force the function to integrate to one, and continue to repeat
 until the difference between the integral and unity is less than a prespecified
 
\begin_inset Formula $\varepsilon$
\end_inset

.
 To be more precise, the algorithm is defined as follows where 
\begin_inset Formula $f_{k}$
\end_inset

 is the kth approximation for the true density function and h(x) is the
 weight function at x.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Normalization of Density Estimate
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $f_{0}(\cdot,x^{n})=\hat{f}(\cdot,x^{n}),\quad k=0$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $f_{1}(\cdot,x^{n})=max(0,f_{k}(\cdot,x^{n})),\quad k=1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $C_{1}=\int_{S}f_{k+1}(t)dt$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
while 
\series default

\begin_inset Formula $\left|C_{k}-1\right|>\epsilon$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $f_{k+1}(\cdot,x^{n})=f_{k}(\cdot,x^{n})-(C_{k}-1)/[h(\cdot)\int_{S}1/h(t)dt$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $f_{k+2}(\cdot,x^{n})=max(0,f_{k+1}(\cdot,x^{n}))$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $C_{k+2}=\int_{S}f_{k+2}(t)dt$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $k=k+2$
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
